
<div  id='write'  class = 'is-node'><h1><a name='header-c1' class='md-header-anchor '></a>对React children 的深入理解（译）</h1><p><a href='http://mxstbr.blog/2017/02/react-children-deepdive/#child-components'>原文链接</a></p><p>React的核心为组件。你可以像嵌套HTML标签一样嵌套使用这些组件，这使得编写JSX更加容易因为它类似于标记语言。</p><p>当我刚开始学习React时，当时我认为“使用 <code>props.children</code> 就这么回事，我知道它的一切”。我错了。。</p><p>因为我们使用的事JavaScript，我们会改变children。我们能够给它们发送特殊的属性，以此来决定它们是否进行渲染。让我们来探究一下React中children的作用。</p><h2><a name='header-c15' class='md-header-anchor '></a>子组件</h2><p>我们有一个组件 <code>&lt;Grid /&gt;</code> 包含了几个组件 <code>&lt;Row /&gt;</code> 。你可能会这么使用它：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;Grid&gt;
  &lt;Row /&gt;
  &lt;Row /&gt;
  &lt;Row /&gt;
&lt;/Grid&gt;</pre><p>这三个 <code>Row</code> 组件都成为了 <code>Grid</code> 的 <code>props.children</code> 。使用一个表达式容器，父组件就能够渲染它们的子组件：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class Grid extends React.Component {
  render() {
    return &lt;div&gt;{this.props.children}&lt;/div&gt;
  }
}</pre><p>父组件也能够决定不渲染任何的子组件或者在渲染之前对它们进行操作。例如，这个 <code>&lt;Fullstop /&gt;</code> 组件就没有渲染它的子组件：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class Fullstop extends React.Component {
  render() {
    return &lt;h1&gt;Hello world!&lt;/h1&gt;
  }
}</pre><p>不管你将什么子组件传递给这个组件，它都只会显示“Hello world!”</p><h2><a name='header-c27' class='md-header-anchor '></a>任何东西都能是一个child</h2><p>React中的Children不一定是组件，它们可以使任何东西。例如，我们能够将上面的文字作为children传递我们的 <code>&lt;Grid /&gt;</code> 组件。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;Grid&gt;Hello world!&lt;/Grid&gt;</pre><p>JSX将会自动删除每行开头和结尾的空格，以及空行。它还会把字符串中间的空白行压缩为一个空格。</p><p>这意味着以下的这些例子都会渲染出一样的情况：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;Grid&gt;Hello world!&lt;/Grid&gt;

&lt;Grid&gt;
  Hello world!
&lt;/Grid&gt;

&lt;Grid&gt;
  Hello
  world!
&lt;/Grid&gt;

&lt;Grid&gt;

  Hello world!
&lt;/Grid&gt;</pre><p>你也可以将多种类型的children完美的结合在一起：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;Grid&gt;
  Here is a row:
  &lt;Row /&gt;
  Here is another row:
  &lt;Row /&gt;
&lt;/Grid&gt;</pre><h2><a name='header-c39' class='md-header-anchor '></a>child 的功能</h2><p>我们能够传递任何的JavaScript表达式作为children，包括函数。</p><p>为了说明这种情况，以下是一个组件，它将执行一个传递过来的作为child的函数：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class Executioner extends React.Component {
  render() {
    // See how we&#39;re calling the child as a function?
    //                        ↓
    return this.props.children()
  }
}</pre><p>你会像这样的使用这个组件</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;Executioner&gt;
  {() =&gt; &lt;h1&gt;Hello World!&lt;/h1&gt;}
&lt;/Executioner&gt;</pre><p>当然，这个例子并没什么用，只是展示了这个想法。</p><p>假设你想从服务器获取一些数据。你能使用多种方法实现，像这种将函数作为child的方法也是可行的。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;Fetch url=&quot;api.myself.com&quot;&gt;
  {(result) =&gt; &lt;p&gt;{result}&lt;/p&gt;}
&lt;/Fetch&gt;</pre><p>不要担心这些超出了你的脑容量。我想要的是当你以后遇到这种情况时不再惊讶。有了children什么事都会发生。</p><h2><a name='header-c55' class='md-header-anchor '></a>操作children</h2><p>如果你看过React的文档你就会说“children是一个不透明的数据结构”。从本质上来讲， <code>props.children</code> 可以使任何的类型，比如数组、函数、对象等等。</p><p>React提供了一系列的函数助手来使得操作children更加方便。</p><h3><a name='header-c60' class='md-header-anchor '></a>循环</h3><p>两个最显眼的函数助手就是 <code>React.Children.map</code> 以及 <code>React.Children.forEach</code> 。它们在对应数组的情况下能起作用，除此之外，当函数、对象或者任何东西作为children传递时，它们也会起作用。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class IgnoreFirstChild extends React.Component {
  render() {
    const children = this.props.children
    return (
      &lt;div&gt;
        {React.Children.map(children, (child, i) =&gt; {
          // Ignore the first child
          if (i &lt; 1) return
          return child
        })}
      &lt;/div&gt;
    )
  }
}</pre><p><code>&lt;IgnoreFirstChild /&gt;</code> 组件在这里会遍历所有的children，忽略第一个child然后返回其他的。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;IgnoreFirstChild&gt;
  &lt;h1&gt;First&lt;/h1&gt;
  &lt;h1&gt;Second&lt;/h1&gt; // &lt;- Only this is rendered
&lt;/IgnoreFirstChild&gt;</pre><p>在这种情况下，我们也可以使用 <code>this.props.children.map</code> 的方法。但要是有人讲一个函数作为child传递过来将会发生什么呢？<code>this.props.children</code> 会是一个函数而不是一个数组，接着我们就会产生一个error！</p><p><img src='http://mxstbr.blog/img/react-children-error.png' alt='err' /></p><p>然而使用 <code>React.Children.map</code> 函数，无论什么都不会报错。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;IgnoreFirstChild&gt;
  {() =&gt; &lt;h1&gt;First&lt;/h1&gt;} // &lt;- Ignored 💪
&lt;/IgnoreFirstChild&gt;</pre><h3><a name='header-c74' class='md-header-anchor '></a>计数</h3><p>因为<code>this.props.children</code> 可以是任何类型的，检查一个组件有多少个children是非常困难的。天真的使用 <code>this.props.children.length</code> ，当传递了字符串或者函数时程序便会中断。假设我们有个child：<code>&quot;Hello World!&quot;</code> ，但是使用 <code>.length</code> 的方法将会显示为12。</p><p>这就是为什么我们有 <code>React.Children.count</code> 方法的原因</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class ChildrenCounter extends React.Component {
  render() {
    return &lt;p&gt;React.Children.count(this.props.children)&lt;/p&gt;
  }
}</pre><p>无论时什么类型它都会返回children的数量</p><pre class='md-fences mock-cm' style='display:block;position:relative'>// Renders &quot;1&quot;
&lt;ChildrenCounter&gt;
  Second!
&lt;/ChildrenCounter&gt;

// Renders &quot;2&quot;
&lt;ChildrenCounter&gt;
  &lt;p&gt;First&lt;/p&gt;
  &lt;ChildComponent /&gt;
&lt;/ChildrenCounter&gt;

// Renders &quot;3&quot;
&lt;ChildrenCounter&gt;
  {() =&gt; &lt;h1&gt;First!&lt;/h1&gt;}
  Second!
  &lt;p&gt;Third!&lt;/p&gt;
&lt;/ChildrenCounter&gt;</pre><h3><a name='header-c83' class='md-header-anchor '></a>转换为数组</h3><p>如果以上的方法你都不适合，你能将children转换为数组通过 <code>React.Children.toArray</code> 方法。如果你需要对它们进行排序，这个方法是非常有用的。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class Sort extends React.Component {
  render() {
    const children = React.Children.toArray(this.props.children)
    // Sort and render the children
    return &lt;p&gt;{children.sort().join(&#39; &#39;)}&lt;/p&gt;
  }
}</pre><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;Sort&gt;
  // We use expression containers to make sure our strings
  // are passed as three children, not as one string
  {&#39;bananas&#39;}{&#39;oranges&#39;}{&#39;apples&#39;}
&lt;/Sort&gt;</pre><p>上例会渲染为三个排好序的字符串。</p><p><img src='http://mxstbr.blog/img/react-children-apples-bananas-oranges.png' alt='sort' /></p><h3><a name='header-c92' class='md-header-anchor '></a>执行单一child</h3><p>如果你回过来想刚才的 <code>&lt;Executioner /&gt;</code> 组件，它只能在传递单一child的情况下使用，而且child必须为函数。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class Executioner extends React.Component {
  render() {
    return this.props.children()
  }
}</pre><p>我们可以试着去强制执行 <code>propTypes</code> ，就像下面这样</p><pre class='md-fences mock-cm' style='display:block;position:relative'>Executioner.propTypes = {
  children: React.PropTypes.func.isRequired,
}</pre><p>这会使控制台打印出一条消息，部分的开发者将会把它忽视。相反的，我们可以使用在 <code>render</code> 里面使用 <code>React.Children.only</code> </p><pre class='md-fences mock-cm' style='display:block;position:relative'>class Executioner extends React.Component {
  render() {
    return React.Children.only(this.props.children)()
  }
}</pre><p>这样只会返回一个child。如果不止一个child，它就会抛出错误，让整个程序陷入中断——完美的避开了试图破坏组件的懒惰的开发者。</p><h2><a name='header-c104' class='md-header-anchor '></a>编辑children</h2><p>我们可以将任意的组件呈现为children，但是任然可以用父组件去控制它们，而不是用渲染的组件。为了说明这点，让我们举例一个 能够拥有很多 <code>RadioButton</code> 组件的 <code>RadiaGroup</code> 组件。</p><p><code>RadioButtons</code> 不会从 <code>RadioGroup</code> 本身上进行渲染，它们只是作为children使用。这意味着我们将会有这样的代码。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>render() {
  return(
    &lt;RadioGroup&gt;
      &lt;RadioButton value=&quot;first&quot;&gt;First&lt;/RadioButton&gt;
      &lt;RadioButton value=&quot;second&quot;&gt;Second&lt;/RadioButton&gt;
      &lt;RadioButton value=&quot;third&quot;&gt;Third&lt;/RadioButton&gt;
    &lt;/RadioGroup&gt;
  )
}</pre><p>这段代码有一个问题。<code>input</code> 没有被分组，导致了这样：</p><p><img src='http://mxstbr.blog/img/react-children-radio-bug.png' alt='' /></p><p>为了把 <code>input</code> 标签弄到同组，必须拥有相同的<code>name</code> 属性。当然我们可以直接给每个<code>RadioButton</code> 的<code>name</code> 赋值</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;RadioGroup&gt;
  &lt;RadioButton name=&quot;g1&quot; value=&quot;first&quot;&gt;First&lt;/RadioButton&gt;
  &lt;RadioButton name=&quot;g1&quot; value=&quot;second&quot;&gt;Second&lt;/RadioButton&gt;
  &lt;RadioButton name=&quot;g1&quot; value=&quot;third&quot;&gt;Third&lt;/RadioButton&gt;
&lt;/RadioGroup&gt;</pre><p>但是这个是无聊的并且容易出错。我们可是拥有JavaScript的所有功能的！</p><h3><a name='header-c119' class='md-header-anchor '></a>改变children的属性</h3><p>在<code>RadioGroup</code> 中我们将会添加一个叫做 <code>renderChildren</code> 的方法，在这里我们编辑children的属性</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class RadioGroup extends React.Component {
  constructor() {
    super()
    // Bind the method to the component context
    this.renderChildren = this.renderChildren.bind(this)
  }

  renderChildren() {
    // TODO: Change the name prop of all children
    // to this.props.name
    return this.props.children
  }

  render() {
    return (
      &lt;div className=&quot;group&quot;&gt;
        {this.renderChildren()}
      &lt;/div&gt;
    )
  }
}</pre><p>让我们开始遍历children获得每个child</p><pre class='md-fences mock-cm' style='display:block;position:relative'>renderChildren() {
  return React.Children.map(this.props.children, child =&gt; {
    // TODO: Change the name prop to this.props.name
    return child
  })
}</pre><p>我们如何编辑它们的属性呢？</p><h3><a name='header-c128' class='md-header-anchor '></a>永恒地克隆元素</h3><p>这是今天展示的最后一个辅助方法。顾名思义，<code>React.cloneElement</code> 会克隆一个元素。我们将想要克隆的元素当作第一个参数，然后将想要设置的属性以对象的方式作为第二个参数。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>const cloned = React.cloneElement(element, {
  new: &#39;yes!&#39;
})</pre><p>现在，<code>clone</code> 元素有了设置为 <code>&quot;yes!&quot;</code> 的属性 <code>new</code> </p><p>这正是我们的 <code>RadioGroup</code> 所需的。我们克隆所有的child并且设置<code>name</code> 属性</p><pre class='md-fences mock-cm' style='display:block;position:relative'>renderChildren() {
  return React.Children.map(this.props.children, child =&gt; {
    return React.cloneElement(child, {
      name: this.props.name
    })
  })
}</pre><p>最后一步就是传递一个唯一的 <code>name</code> 给<code>RadioGroup</code> </p><pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;RadioGroup name=&quot;g1&quot;&gt;
  &lt;RadioButton value=&quot;first&quot;&gt;First&lt;/RadioButton&gt;
  &lt;RadioButton value=&quot;second&quot;&gt;Second&lt;/RadioButton&gt;
  &lt;RadioButton value=&quot;third&quot;&gt;Third&lt;/RadioButton&gt;
&lt;/RadioGroup&gt;</pre><p><img src='http://mxstbr.blog/img/react-children-radio-done.png' alt='' /></p><p>没有手动添加 <code>name</code> 属性给所有的 <code>RadioButton</code> ，我们只是告诉了 <code>RadioGroup</code> 所需的name而已。</p><h2><a name='header-c144' class='md-header-anchor '></a>总结</h2><p>Children使React组件更像是标记而不是 脱节的实体。通过强大的JavaScript和一些React帮助函数使我们的生活更加简单。</p></div>
